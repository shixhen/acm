#include <bits/stdc++.h>
using namespace std;

const int N=2e5+86;

int n,l,r,v[N];
//有负数所以 ans 初始化为负无穷

int main()
{
    int t = 0;
    int h = 1;
    int ans = -0x3f3f3f3f;
    scanf("%d%d%d",&n,&l,&r);
    if(l>r) swap(l,r); //鲁棒性检查，确保l<=r
    vector<int> dq(n + 2); // 单调队列，存储位置索引
    vector<int> dp(n + 1, INT_MIN);
    dp[0] = 0; // 起始位置的冰冻指数为0
    for(int i=0;i<=n;i++)
        scanf("%d",&v[i]);
    
    // 动态规划：dp[i] = 到达位置i能获得的最大冰冻指数
    // 状态转移：dp[i] = max(dp[j]) + v[i]，其中 j ∈ [i-r, i-l]
    // 使用单调队列优化区间最值查询
    
    for(int i=l;i<=n;i++)  // 从第一个可达位置开始
    {
        // 维护单调队列：队列中存储的是位置索引，按dp值单调递减
        
        // 1. 移除队头过期元素：超出转移范围[i-r, i-l]的元素
        while(h<=t && dq[h]<i-r) h++;
        
        // 2. 移除队尾较小元素：保持单调性
        while(h<=t && dp[dq[t]]<=dp[i-l]) t--;
        
        // 3. 将新的候选位置i-l加入队尾
        dq[++t]=i-l;
        
        // 4. 状态转移：队头就是区间[i-r, i-l]中dp值最大的位置
        dp[i]=dp[dq[h]]+v[i];
        
        // 5. 检查是否能到达对岸：如果从位置i跳跃能超过n，则更新答案
        if(i+r>n) 
            ans=max(dp[i],ans);
    }
    
    printf("%d\n",ans);
    return 0;
}

/* 算法解释：
 * 1. 状态定义：dp[i] = 到达位置i的最大冰冻指数
 * 
 * 2. 状态转移：dp[i] = max{dp[j] : j∈[i-r,i-l]} + v[i]
 *    意思是：要到达位置i，必须从某个位置j跳过来，
 *    而j的范围是[i-r, i-l]（因为从j能跳到[j+l, j+r]，要包含i）
 * 
 * 3. 单调队列优化：
 *    - 朴素做法：每次计算dp[i]都要遍历[i-r,i-l]找最大值，O(n²)
 *    - 优化思路：维护一个单调递减队列，队头始终是当前区间的最大值
 *    - 队列存储位置索引，按对应的dp值单调递减排列
 * 
 * 4. 单调队列操作：
 *    - 入队前：移除队尾所有dp值≤新元素的位置（保持单调性）
 *    - 查询前：移除队头所有超出查询范围的位置
 *    - 查询：队头就是当前区间的最大值位置
 * 
 * 5. 边界处理：
 *    - dp[0]=v[0]=0（起始位置）
 *    - 从位置l开始计算（因为最小跳跃距离是l）
 *    - 当i+r>n时，说明可以从位置i跳到对岸
 */